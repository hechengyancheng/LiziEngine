
# LiziEngine 重构版

## 项目概述

LiziEngine 是一个向量场可视化和编辑工具，经过重构后采用了更清晰的模块化架构，提高了代码的可维护性和可扩展性。

## 架构设计

### 核心模块 (core/)

- **events.py**: 事件系统，提供发布-订阅模式的事件通信机制
- **state.py**: 状态管理，提供线程安全的状态管理功能
- **config.py**: 配置管理，提供统一的配置加载和管理功能
- **app.py**: 应用核心，整合各个管理器，提供应用程序的主要功能
- **controller.py**: 应用控制器，整合各个模块，提供应用程序的主要控制逻辑

### 计算模块 (compute/)

- **vector_field.py**: 向量场计算，提供向量场计算的核心功能
- **gpu_compute.py**: GPU计算，提供基于GPU的向量场计算功能

### 图形模块 (graphics/)

- **renderer.py**: 渲染器，提供向量场的渲染功能
- **window.py**: 窗口管理，提供OpenGL窗口的创建和管理功能

### 用户界面模块 (ui/)

- **toolbar.py**: 工具栏，提供用户界面工具栏功能

## 主要改进

1. **模块化设计**: 将代码按功能划分为多个模块，每个模块职责单一
2. **事件驱动**: 采用事件系统进行模块间通信，降低耦合度
3. **状态集中管理**: 统一的状态管理，避免全局变量滥用
4. **配置统一管理**: 集中的配置管理，支持动态配置
5. **资源管理**: 更好的资源生命周期管理，防止内存泄漏

## 使用方法

### 安装依赖

基本依赖（必须安装）：
```bash
pip install -r requirements.txt
```

可选依赖（用于图形界面工具栏）：
```bash
pip install imgui[glfw]
```

注意：如果安装imgui时遇到编译错误，可以尝试以下方法：
1. 安装Visual Studio Build Tools（Windows）
2. 或者使用预编译的wheel包：`pip install --only-binary=all imgui`
3. 如果仍然失败，程序会自动使用简单的键盘快捷键工具栏

### 运行应用

```bash
python run.py
```

### 工具栏类型

LiziEngine 支持两种工具栏类型：
1. **ImGui工具栏**：图形界面，需要安装 `imgui[glfw]`
2. **简单工具栏**：基于键盘快捷键，无需额外依赖

默认情况下，程序会自动检测ImGui是否可用，并选择合适的工具栏类型。你也可以通过修改 `run.py` 中的 `create_toolbar()` 调用来指定工具栏类型：

```python
# 使用ImGui工具栏
toolbar = create_toolbar("imgui")

# 使用简单工具栏
toolbar = create_toolbar("simple")

# 自动选择（默认）
toolbar = create_toolbar("auto")
```

### 配置文件

配置文件支持JSON格式和键值对格式，默认配置文件为 `config.json`。

## 快速入门

1. 运行 `python run.py` 启动应用
2. 使用鼠标左键在网格上绘制向量
3. 使用工具栏调整画笔大小、向量大小等参数
4. 使用快捷键：
   - G: 切换网格显示
   - R: 重置视图
   - C: 清空网格
   - T: 切换工具栏显示
   - H: 显示帮助信息
   - +/-: 增加/减少画笔大小
   - </>: 增加/减少向量大小
   - V: 切换向量方向

## 开发指南

### 添加新功能

1. 在相应的模块中添加新功能
2. 通过事件系统与其他模块通信
3. 更新配置文件（如需要）
4. 更新状态（如需要）

### 自定义渲染器

1. 继承 `VectorFieldRenderer` 类
2. 重写相应的渲染方法
3. 在应用控制器中注册新的渲染器

### 自定义计算器

1. 继承 `VectorFieldCalculator` 类
2. 实现自定义的计算方法
3. 在应用控制器中注册新的计算器

## 注意事项

1. 避免直接修改其他模块的内部状态
2. 使用事件系统进行模块间通信
3. 遵循单一职责原则
4. 保持配置和状态的一致性
